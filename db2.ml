(* DB2 - roughly equivalent to what we have in xapi at time of writing. *)

module StringMap = Map.Make(String)

module type VAL = sig
  type t
end

module Make (V : VAL) = struct
  type t = V.t StringMap.t
  let empty = StringMap.empty
  let add = StringMap.add
  let find = StringMap.find
  let mem = StringMap.mem
  let remove = StringMap.remove
  let update key default f t =
    let cur = if mem key t then find key t else default in
    let newv = f cur in
    StringMap.add key newv t
  let iter = StringMap.iter
end

module Row = struct
  include Make(String)
end

module Table = struct
  include Make(Row)
end

module TableSet = struct
  include Make(Table)
end

module Database = struct
  type t = TableSet.t
  let empty = TableSet.empty
end

let get_field tblname objref fldname db =
  TableSet.find tblname db |>
  Table.find objref |>
  Row.find fldname

let set_field tblname objref fldname v : Database.t -> Database.t =
  (function _ -> v)
  |> Row.update fldname ""
  |> Table.update objref Row.empty
  |> TableSet.update tblname Table.empty

let dump db =
  TableSet.iter (fun tblname table ->
    Printf.printf "\n# TABLE: %s\n\n" tblname;
    Table.iter (fun objref row ->
      Printf.printf "## Object: %s\n" objref;
      Row.iter (fun fldname v ->
        Printf.printf "  %s: %s\n" fldname v) row) table) db


let db = ref Database.empty


(* Phantom-type-using references *)
module Ref : sig
  type 'c t
  val string_of : 'c t -> string
  val of_string : string -> 'c t
  val pp : Format.formatter -> 'c t -> unit
end = struct
  type 'c t = string
  let string_of v = v
  let of_string v = v
  let pp fmt v = Format.pp_print_string fmt v
end

(* The following 4 modules would normally be constructed from code generated by datamodel definitions *)

module DM_to_String = struct
  let vbd_set vbds = String.concat "," (List.map Ref.string_of vbds)
end

module String_to_DM = struct
  let vbd_set : string -> [`vbd] Ref.t list = fun str -> Astring.String.cuts ~sep:"," str |> List.map Ref.of_string
end

module VM : sig
  val set_name_label : [`vm] Ref.t -> string -> unit
  val get_name_label : [`vm] Ref.t -> string
  val set_memory : [`vm] Ref.t -> int -> unit
  val get_memory : [`vm] Ref.t -> int
  val set_VBDs : [`vm] Ref.t -> [`vbd] Ref.t list -> unit
  val get_VBDs : [`vm] Ref.t -> [`vbd] Ref.t list
end = struct
  let set_name_label self v =
    db := set_field "VM" (Ref.string_of self) "name_label" v !db

  let get_name_label self =
    get_field "VM" (Ref.string_of self) "name_label" !db

  let set_memory self v =
    db := set_field "VM" (Ref.string_of self) "memory" (string_of_int v) !db

  let get_memory self =
    get_field "VM" (Ref.string_of self) "memory" !db |> int_of_string

  let set_VBDs self v =
    db := set_field "VM" (Ref.string_of self) "VBDs" (DM_to_String.vbd_set v) !db

  let get_VBDs self =
    get_field "VM" (Ref.string_of self) "VBDs" !db |> String_to_DM.vbd_set
end

module VBD : sig
  val set_VM : [`vbd] Ref.t -> [`vm] Ref.t -> unit
  val get_VM : [`vbd] Ref.t -> [`vm] Ref.t
end = struct
  let set_VM self v =
    db := set_field "VBD" (Ref.string_of self) "VM" (Ref.string_of v) !db

  let get_VM self =
    get_field "VBD" (Ref.string_of self) "VM" !db |> Ref.of_string
end

(* Example showing how we would use these in practice *)

let vm : [`vm] Ref.t = Ref.of_string "OpaqueRef:abcde"
let vbd1 : [`vbd] Ref.t = Ref.of_string "OpaqueRef:fghij"
let vbd2 : [`vbd] Ref.t = Ref.of_string "OpaqueRef:12345"

let _ =
  VM.set_name_label vm "my first vm";
  VBD.set_VM vbd1 vm;
  VBD.set_VM vbd2 vm;
  VM.set_VBDs vm [vbd1; vbd2];
  VM.set_memory vm 63356;
