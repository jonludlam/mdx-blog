(* DB3 - typed fields *)

module StringMap = Map.Make(String)

module type VAL = sig
  type t
end

module Make (V : VAL) = struct
  type t = V.t StringMap.t
  let empty = StringMap.empty
  let add = StringMap.add
  let find = StringMap.find
  let mem = StringMap.mem
  let remove = StringMap.remove
  let update key default f t =
    let cur = if mem key t then find key t else default in
    let newv = f cur in
    StringMap.add key newv t
  let iter = StringMap.iter
end

module Row = struct
  include Make(String)
end

module Table = struct
  include Make(Row)
end

module TableSet = struct
  include Make(Table)
end

module Database = struct
  type t = TableSet.t
  let empty = TableSet.empty
end

let get_field tblname objref fldname db =
  TableSet.find tblname db |>
  Table.find objref |>
  Row.find fldname

let set_field tblname objref fldname v : Database.t -> Database.t =
  (function _ -> v)
  |> Row.update fldname ""
  |> Table.update objref Row.empty
  |> TableSet.update tblname Table.empty

let dump db =
  TableSet.iter (fun tblname table ->
    Printf.printf "\n# TABLE: %s\n\n" tblname;
    Table.iter (fun objref row ->
      Printf.printf "## Object: %s\n" objref;
      Row.iter (fun fldname v ->
        Printf.printf "  %s: %s\n" fldname v) row) table) db


let db = ref Database.empty


(* Phantom-type-using references *)
module Ref : sig
  type 'c t
  val string_of : 'c t -> string
  val of_string : string -> 'c t
  val pp : Format.formatter -> 'c t -> unit
end = struct
  type 'c t = string
  let string_of v = v
  let of_string v = v
  let pp fmt v = Format.pp_print_string fmt v
end

(* The following 2 modules would normally be constructed from code generated by datamodel definitions *)

module DM_to_String = struct
  let vbd_set vbds = String.concat "," (List.map Ref.string_of vbds)
end

module String_to_DM = struct
  let vbd_set : string -> [`vbd] Ref.t list = fun str -> Astring.String.cuts ~sep:"," str |> List.map Ref.of_string
end

(* Our typed field - should be in datamodel.ml but currently needs to use String_of_DM *)
module Field : sig
  type ('c, 'f) t
  val construct : string -> string -> (string -> 'f) -> ('f -> string) -> ('c, 'f) t
  val name_of : ('c, 'f) t -> string
  val table_of : ('c, 'f) t -> string
  val string_of_value : ('c, 'f) t -> 'f -> string
  val value_of_string : ('c, 'f) t -> string -> 'f
end = struct
  type ('c,'f) t = {
    name : string;
    table : string;
    value_of_string : string -> 'f;
    string_of_value : 'f -> string;
  }
  let name_of x = x.name
  let table_of x = x.table
  let construct name table value_of_string string_of_value = {name; table; value_of_string; string_of_value;}
  let string_of_value x = x.string_of_value
  let value_of_string x = x.value_of_string
end

let set : 'c Ref.t -> ('c,'f) Field.t -> 'f -> unit = fun ref field v ->
  db := set_field (Field.table_of field) (Ref.string_of ref) (Field.name_of field) (Field.string_of_value field v) !db

let get : 'c Ref.t -> ('c,'f) Field.t -> 'f = fun ref field ->
  get_field (Field.table_of field) (Ref.string_of ref) (Field.name_of field) !db |> Field.value_of_string field

(* Example showing how we would use these in practice *)

let vm : [`vm] Ref.t = Ref.of_string "OpaqueRef:abcde"
let vbd1 : [`vbd] Ref.t = Ref.of_string "OpaqueRef:fghij"
let vbd2 : [`vbd] Ref.t = Ref.of_string "OpaqueRef:12345"

let name_label : ([`vm], string) Field.t = Field.construct "name_label" "VM" (fun x -> x) (fun x -> x)
let vBDs : ([`vm], [`vbd] Ref.t list) Field.t = Field.construct "VBDs" "VM" String_to_DM.vbd_set DM_to_String.vbd_set
let vbd_vm : ([`vbd], [`vm] Ref.t) Field.t = Field.construct "VM" "VBD" (Ref.of_string) (Ref.string_of)
let memory : ([`vm], int) Field.t = Field.construct "memory" "VM" (int_of_string) (string_of_int)

let _ =
  set vm name_label "my first vm";
  set vbd1 vbd_vm vm;
  set vbd2 vbd_vm vm;
  set vm vBDs [vbd1; vbd2];
  set vm memory 63356;
  dump !db


